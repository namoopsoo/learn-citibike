#!/usr/bin/env python

# A sample training component that trains a simple scikit-learn decision tree model.
# This implementation works in File mode and makes no assumptions about the input file names.
# Input is specified as CSV with a data point in each row and the labels in the first column.

from __future__ import print_function

import os
import json
import cPickle
import sys
import traceback
import uuid

import pandas as pd

from sklearn import tree
import xgboost

from bikelearn.models import treefoo as bikemodel
from bikelearn import pipeline_data as pl

# These are the paths to where SageMaker mounts interesting things in your container.

prefix = '/opt/ml/'

input_path = prefix + 'input/data'
output_path = os.path.join(prefix, 'output')
model_path = os.path.join(prefix, 'model')
param_path = os.path.join(prefix, 'input/config/hyperparameters.json')
config_path = os.path.join(prefix, 'input/config')

# This algorithm has a single channel of input data called 'training'. Since we run in
# File mode, the input files are copied to the directory specified here.
training_path = os.path.join(input_path, 'training')
testing_path = os.path.join(input_path, 'testing')

def whats_stations_filename():
    stations_dir = os.path.join(training_path, 'support')
    print("DEBUG, stations_dir, " + stations_dir)

    stations_fn_list = [file
            for file in
            os.listdir(stations_dir)]

    print('DEBUG, stations_fn_list , ' + str(stations_fn_list))
    assert len(stations_fn_list) == 1, 'should be one file here'

    stations_fn = stations_fn_list[0]

    return os.path.join(stations_dir, stations_fn)


def train():
    train_fn = what_are_train_files()[-1]
    test_fn = what_are_test_files()[-1]
    print('DEBUG, train_fn, ' + train_fn)
    print('DEBUG, test_fn, ' + test_fn)
    # trainset = pd.read_csv(fn, header=None) # Hmm..

    stations_fn = whats_stations_filename()
    stations_df = pd.read_csv(stations_fn)
    hyperparameters = read_hyperparams()
    print('DEBUG, hyperparameters, ' + hyperparameters)

    try:
        bundle = bikemodel.make_tree_foo(
                {'train_fn': train_fn,
                    'trainset': pd.read_csv(train_fn),
                    'testset': pd.read_csv(test_fn),
                    'test_fn': test_fn},
                {'stations_df': stations_df, 'fn': stations_fn},
                hyperparameters)

        # TODO... do the test set too..
    except Exception as e:
        # Write out an error file. This will be returned as the failureReason in the
        # DescribeTrainingJob result.
        trc = traceback.format_exc()
        fn = 'failure.{}.log'.format(pl.make_timestamp())
        with open(os.path.join(output_path, fn), 'w') as s:
            s.write('Exception during training: ' + str(e) + '\n' + trc)
        # Printing this causes the exception to be in the training job logs, as well.
        print('Exception during training: ' + str(e) + '\n' + trc, file=sys.stderr)
        # A non-zero exit code causes the training job to be marked as Failed.
        sys.exit(255)

    # save bundle ...
    save_model(bundle)


def what_are_train_files():
    return what_are_channel_files(training_path)


def what_are_test_files():
    return what_are_channel_files(testing_path)


def what_are_channel_files(channel_path):
    # Take the set of files and read them all into a single pandas dataframe
    print('DEBUG, channel_path, ' + channel_path)

    print('DEBUG, os.listdir(channel_path), ' + str(
        os.listdir(channel_path)))
    input_files = [
            os.path.join(channel_path, file)
            for file in
            filter(lambda x: x != 'support' and x.endswith('.csv'),
                os.listdir(channel_path))]

    print('DEBUG, input_files , ')
    print(str(input_files))

    if len(input_files) == 0:
        raise ValueError(('There are no files in {}.\n'
                    + 'This usually indicates that '
                    + 'the channel was incorrectly'
                    + ' specified,\n'
                    + 'the data specification in S3 '
                    + ' was incorrectly specified or '
                    + ' the role specified\n'
                    + 'does not have permission to '
                    + ' access the data.').format(
                            channel_path))

    return input_files

def read_hyperparams():
    with open(param_path, 'r') as tc:
        hyperparameters = json.load(tc)
    return hyperparameters


def save_model(bundle):
    output_name = '{}.{}.pkl'.format(bundle['bundle_name'],
            bundle['timestamp'])
    with open(
            os.path.join(model_path, output_name), 'w') as out:
        cPickle.dump(bundle, out)



if __name__ == '__main__':
    train()

    # A zero exit code causes the job to be marked a Succeeded.
    sys.exit(0)


