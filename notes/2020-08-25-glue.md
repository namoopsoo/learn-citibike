

#### making the tarball from the joblib..

```
cd artifacts/2020-08-19T144654Z

ls
# => all_bundle_with_stationsdf.joblib

mkdir model

mv all_bundle_with_stationsdf.joblib model

tar -czf model.tar.gz model
# => creates model.tar.gz , which I can throw into a SageMaker model.

```

#### troubleshoot docker does not run serve command...
- is it not executable? Wrong work dir?

```
$ docker run -p 8889:8889 -p 8080:8080 -i -t -v $(pwd):/opt/program       \
      -v ${my_local_data_directory}:/opt/data        \
      -v   ~/Downloads:/opt/downloads         \
      -v  $(pwd)/artifacts/2020-08-19T144654Z:/opt/ml   citibike-learn:latest  serve

docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused "exec: \"serve\": executable file not found in $PATH": unknown.



```

* Maybe some help [here](https://stackoverflow.com/questions/27158840/docker-executable-file-not-found-in-path) , or [here](https://docs.docker.com/engine/reference/builder/#/cmd)  , with the use of a `CMD` word in the `Dockerfile` .


### 2020-08-26

#### dockerfile
* ok i had just needed to add `/opt/server` to the `PATH` and that fixed it


#### for the probabily outputs from xgboost, got to map those to neighborhoods
* this is the next thing
* and put that mapping into `fresh/lambda.py`
* This information should be in the bundle too. along with the input header too.

#### 54
* `54` output probabilities.


### 2020-08-29

#### test entry code

```python
import fresh.lambda_entry as fl

fl.entry(None, None)

bundle = fl.fetch_bundle()
```

* hmm the bundle requires xgboost, which locally (except for Docker) I dont have and lambda also will not have
* making a slimmed bundle w/o the model...

```python
import fresh.predict_utils as fpu
import joblib
bundle = fpu.load_bundle_in_docker()
del bundle['model_bundle']['bundle']['xgb_model']

blahdir = '/opt/program/artifacts/2020-08-19T144654Z'

joblib.dump(bundle, f'{blahdir}/all_bundle_with_stationsdf_except_xgb.joblib')

```
* And then I saved that to my s3 location
* Try main entry func again w/ the no-xgb bundle

```python
import fresh.lambda_entry as fl
bundle = fl.fetch_bundle()
# fl.map_probabilities(bundle, prob_vec, k=5)
```

* hmm got a scikit learn error now

```
ModuleNotFoundError: No module named 'sklearn.preprocessing._label'
```
* not sure if it helps, but going to align my version ..


```
In [92]: sklearn.__version__                                                                                          
Out[92]: '0.20.2'

In [93]: !pip install -U scikit-learn==0.22.1
```
* oh wow... I tried `fetch_bundle` again after that and bingo!

* ok try also w/ map probabilities...

```python
import fresh.lambda_entry as fl
bundle = fl.fetch_bundle()
out = fl.entry(None, None)

fl.map_probabilities(bundle, prob_vec=out['result'][0], k=5)
```
* ok yay... very cool.

```python
In [8]: fl.map_probabilities(bundle, prob_vec=out['result'][0], k=5)                                                      
Out[8]:
[('Bedford-Stuyvesant', 0.18238812685012817),
 ('Vinegar Hill', 0.0740085020661354),
 ('Columbia Street Waterfront District', 0.07334273308515549),
 ('Downtown Brooklyn', 0.07258936762809753),
 ('Fulton Ferry District', 0.0493587926030159)]
```
* Now just need to add the Google Static Map API call in there. And complete.
* Ah I forgot got a few choices w/ what latlng to chose
```python
stationsdf = bundle['stations_bundle']['stationsdf']
df = fl.map_probabilities(bundle, prob_vec=out['result'][0], k=5)                                                      

In [24]: df.merge(stationsdf, on='neighborhood').iloc[:5][['station_name', 'latlng', 'neighborhood']]                     
Out[24]:
                  station_name                        latlng        neighborhood
0  Lexington Ave & Classon Ave      40.68676793,-73.95928168  Bedford-Stuyvesant
1    Franklin Ave & Myrtle Ave          40.694528,-73.958089  Bedford-Stuyvesant
2   Lefferts Pl & Franklin Ave   40.680342423,-73.9557689392  Bedford-Stuyvesant
3     Hancock St & Bedford Ave      40.68216564,-73.95399026  Bedford-Stuyvesant
4      Macon St & Nostrand Ave  40.6809833854,-73.9500479759  Bedford-Stuyvesant


```
* ..
```python
import fresh.lambda_entry as fl
out = fl.entry(None, None)

```

#### Summary
* Ok cool. i have a full end to end glue now, complete with locations on a static map img tag.

#### Next ...
* I want to just add the 'start' location too. Probably different color label too
* Then place the thing into a lambda
* And then the html side needs to TLC .


### 2020-08-30

#### quick lambda test
* can i even access file system on lambda?

```python
import os
def sage_entry(event, context):
    print(os.getcwd())
    print(os.listdir('.'))

```
* heres what i get

```
/var/task
['lambda_function.py']
```

* ok but when i tried to write ... Damn does not allow.
```python
with open('/var/task/temp.blah', 'w') as fd:
    fd.write('cool beans')
```

```
Response:
{
  "errorMessage": "[Errno 30] Read-only file system: '/var/task/temp.blah'",
  "errorType": "OSError",
  "stackTrace": [
    "  File \"/var/task/lambda_function.py\", line 14, in sage_entry\n    with open('/var/task/temp.blah', 'w') as fd:\n"
  ]
}
```
* So going to have to just embed the information I need in the code itself. Not s3. thats fine.

#### the html side...
* My original demo is [here](https://bike-hop-predict.s3.amazonaws.com/index.html)


### 2020-08-31

#### note
*  ok so since cannot write to file system, must change the entry function since cannot use joblib because it requires disk.
* I can still keep the extra info on s3, just use json or pickle instead since those dont need disk.


```python
In [1]: import joblib                                                           

In [2]: import fresh.lambda_entry as fle                                        

In [3]: bundle = fle.fetch_bundle()

In [6]: import pickle                                                           

In [7]: pkl = pickle.dumps(bundle)                                              

In [8]: import fresh.s3utils as fs3                                             


In [12]: loc = 'bikelearn/artifacts/2020-08-19T144654Z/all_bundle_with_stationsdf_except_xgb.pkl'                                                      

In [13]: fs3.write_s3_file(bucket_name, loc, pkl)                               

```

### 2020-09-02

#### update w that pkl..
* ok cool updated code w/ pkl instead of joblib/disk dependence and all good.

### 2020-09-03

#### Next
* test this code on lambda, along w/ docker update on sagemaker
* the lambda entry must also return the img html to the browser ajax call
* fast follow: the "Source station" should also be a special label in the static map diagram too!
* the API Gateway authentication : how to authenticate now?

#### api gateway authentication
* previously I was using the access keys/secrets as inputs to the actual html form. I guess I can still see if that works?
* that's a super bare bones mvp haha. But might as well see if it works.


#### zip
* uploaded the `foo.zip` created like this to lambda..
```
zip   -r foo fresh -i \*.py
```
* but ran into this on lambda darn..

```
Response:
{
  "errorMessage": "Unable to import module 'fresh.lambda_entry': No module named 'pandas'",
  "errorType": "Runtime.ImportModuleError"
}
```

#### tried another sagemaker model endpoint
* hmm but failed with this ..

```
Traceback (most recent call last):
  File "/opt/conda/lib/python3.7/site-packages/flask/app.py", line 2447, in wsgi_app
    response = self.full_dispatch_request()
  File "/opt/conda/lib/python3.7/site-packages/flask/app.py", line 1952, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/opt/conda/lib/python3.7/site-packages/flask/app.py", line 1821, in handle_user_exception
    reraise(exc_type, exc_value, tb)
  File "/opt/conda/lib/python3.7/site-packages/flask/_compat.py", line 39, in reraise
    raise value
  File "/opt/conda/lib/python3.7/site-packages/flask/app.py", line 1950, in full_dispatch_request
    rv = self.dispatch_request()
  File "/opt/conda/lib/python3.7/site-packages/flask/app.py", line 1936, in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
  File "/opt/server/predictor.py", line 82, in ping
    record = make_canned_record()

NameError: name 'make_canned_record' is not defined
```

#### Summary
* updated lambda entry code to return the map html
* tried another sagemaker docker go.
* zip + a lambda build go.

#### Next
* got to fix that sagemaker `make_canned_record` missing dependency
* pandas into lambda layer + retry
* try pipeline again.


### 2020-09-04

#### pandas layer
* Just out of convenience, I ran this in my running docker. ( Thanks to convenient refresher notes [here](https://medium.com/swlh/how-to-add-python-pandas-layer-to-aws-lambda-bab5ea7ced4f) )
```
mkdir python
pip install -t python pandas pytz
rm -r python/numpy*
```
* Not having `zip` in my docker, i ran the zip part on the mac host
```
zip -r python.zip python

# $ ls -lh python.zip
# 16M
```
* And I uploaded this to s3, and built a lambdas layer
* And the dependency was now good. but failed for joblib!.
* I commented out the joblib but then sklearn. Right also forgot about that.


#### summary
* Ok built pandas layer
* uncommented joblib dependency, but found sklearn dependency also needs to be met


#### NExt
* sklearn dependency needs to be layered up too!.
* And as from earlier, got to re-build the docker image w/ the `make_canned_record` fix.

### 2020-09-05

#### add other dependencies to layers...

```
mkdir python
pip install -t python pandas pytz
rm -r python/numpy*

# adding some more...
pip install -t python scikit-learn==0.22.1

```
*  ok ... made another layer for sklearn

```
zip -r python.zip python

# $ ls -lh python.zip
# 70M

rm -r python/scipy* python/numpy* python/pandas* python/pytz* python/dateutil*
rm -r python/six* python/python_dateutil*

# $ ls -lh python.zip
# 9.8M
```


#### zip lambda code again ...
* (because try except around a tqdm import)
* uploaded the `foo.zip` created like this to lambda..
```
zip   -r foo fresh -i \*.py
```

##### Dang also requests...
* separate layer for that ...

```
mkdir python
pip install -t python requests
```
*
```
zip -r python.zip python
# 904K
```

##### Access denied
* hmm need fix permission for s3...
```
"errorMessage": "An error occurred (AccessDenied) when calling the GetObject operation: Access Denied",
```

* Ah ok ... the reason was that (1) I was missing the GetObject IAM policy from my Lambda Role,
* (2) But then also I had an environmental variable ACCESS KEY I was defining in my `fresh/s3utils.py` code , which also did not have the permission
* So Removing the ACCESS KEY from my Lambda environmental variables and adding the permission to the Lambda Role freed up the lambda to use the permission through the IAM Role itself!

##### ok and rebuild the sagemaker docker ...
* ...  and got to repackage the model again think got to do that differently ..

```
cd artifacts/2020-08-19T144654Z

```

* Ok had to repackage the `model.tar.gz` without the `model` dir.
* and now `purple-bottleneck-epsilon` is In Service

#### Next
* Ok so try to hit sagemaker endpoint from the lambda then.


### 2020-09-07

#### Summary
* ok was able to hit sagemaker endpoint from the lambda after some tweaks.
* Also tested the `index.html` form i have on my s3 bucket, with some random data

#### next
* update the client javascript to embed the image from the response .

### 2020-09-08

#### to be easier, just perhaps a script that pushes my client code to s3
* hmm ok i have a deploys script thats deploying,
* but now the static website no longer serves instead now it is just making me download the index.html for some reason .
* weird.

#### Summary
* got a deploy script to s3 static (but needs tweaking)

#### Next
* Got to make the s3 deploy script not cause the s3 static hosting to break .


### 2020-09-09

#### two domain names..?
* This is the one that worked before I uploaded again  https://bike-hop-predict.s3.amazonaws.com/index.html
* And when I went into "Static website hosting" properties of my S3 bucket, I saw this new url I dont recall http://bike-hop-predict.s3-website-us-east-1.amazonaws.com
* But both prompt to just download the `index.html` file now
* and wow [this doc](https://docs.aws.amazon.com/AmazonS3/latest/dev/IndexDocumentSupport.html) has one more..
http://bike-hop-predict.s3-website.us-east-1.amazonaws.com/
* Hmm I also tried again manually uploading through the console, still not working.
* Per [here](https://stackoverflow.com/questions/25734480/website-hosted-on-s3-just-downloads-a-blank-file#25739950) I did check the `Content-type` and it was already `text/html` but I did just edit and save again. Still nothing.

##### ah uploading again
*  scrolling down, content-type must be selected in the beginning and cannot be changed after uploading
* so this time worked!

#### ok now trying to properly edit the html to insert the img
* so far just displaying the raw <img> html as a string literal
* tried `$('#' + output_id).text(JSON.stringify(response));`  that initially was bad because the `JSON.stringify` was escaping the quotation marks weird
* Then I tried without the `JSON.stringify` but still just raw string. except not escaped
* Then tried `document.getElementById(output_id_2).innerHTML=response['map_html'];`  . that worked except for the first try when I left the `"#"` prepended in the `getElementById`

```
Uncaught TypeError: Cannot set property 'innerHTML' of null
    at Object.success (fetch_data.js:408)
    at i (jquery-3.2.0.min.js:2)
    at Object.fireWith [as resolveWith] (jquery-3.2.0.min.js:2)
    at A (jquery-3.2.0.min.js:4)
    at XMLHttpRequest.<anonymous> (jquery-3.2.0.min.js:4)

```
* So yea now works!


#### Summary
* Yay figured out the weirdness around the content type .
* and updated the javascript to properly edit the inner html to insert the meticulously produced `<img>` tag!.


#### Next
* Should update that s3 deploy to actually use the `content-type` as `text/html` if I want to use that again.
* easier authentication for a true easy to use demo.
* and eventually just drop downs much easier to use


### 2020-09-10

#### hmm cognito?
* Ok cool per [docs](https://docs.aws.amazon.com/cognito/latest/developerguide/identity-pools.html#authenticated-and-unauthenticated-identities) I was able to create an "Unautenticated Identity Pool" for "Guests" who do not have to autenticate by definition.
* Wow that's exactly what I need. And this connects to an IAM role too. Quite nifty.
* Also this [starter javascript guide](https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/getting-started-browser.html) first helps with talking to cognito and then connects to Amazon Polly which converts text to speech . Haha.
* So per the steps, I attached `AmazonPollyFullAccess` to my new Unauthenticated Role.
* Ok wow the demo html worked right out of the box.

#### Summary
* Got an unauthenticated cognito identity pool created
* And tried out the identity pool with the Amazon Polly demo. Worked out of the box.

#### Next
* Use this unauthenticated identity pool with my API gateway.

### 2020-09-11

#### javascript plus cognito
* trying to decipher some of the docs like [this one](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-generate-sdk-javascript.html)  .. There is something like `"lib/apiGatewayCore/apiGatewayClient.js"`
* The [sdk doc here](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/ApiGatewayV2.html) seems to describe managing the APIGateway not actually executing API . Umm ok.
* But reading [here](https://stackoverflow.com/questions/57680057/how-to-use-aws-cognito-to-authenticate-api-gateway) and [here](https://www.codeproject.com/Articles/5255224/Calling-API-Gateway-Cognito-from-JavaScript)  , I think the client makes a call first to get back a "Cognito-signed JWT (JSON Web Token)" and that can be used perhaps in the typical aws signing process, like what I currently use with `aws-sign-web.js`  
* Oh actually [this guide](https://github.com/mcasperson/AWSCognitoJavaScript) looks pretty detailed.
* But according to [here](https://aws-amplify.github.io/docs/) Amplify requires `$ npm install -g @aws-amplify/cli` which is a next level of intensity for sure.

#### Summary
* Created an Authorizer using Cognito.
* Researched how to actually use cognito on javascript. Found some bits and pieces of examples.

#### next
* maybe as a proof of concept, I should figure out how to make the Polly example I have spit out an Authorization token, and try using that  in a vanilla request to the API. Maybe that actually works? Maybe Cognito lets you avoid the whole AWS Signature v4 thing?
* Also interestingly enough maybe since the `AWS.config.credentials` javascript thing seems to have `accessKeyId` and `secretAccessKey` ... maybe that means something?

### 2020-09-12

#### I tried just defining the credentials, but still empty
* Using just this below, did not work

```
AWS.config.region = 'MY_REGION';
AWS.config.credentials = new AWS.CognitoIdentityCredentials({
  IdentityPoolId: 'MY_IDENTITY_POOL'
});
```
* The credentials were blank, as if like uninitialized. Probably they get filled in during the `AWS.Polly()`  service call itself?

#### hmm maybe getGatewayResponse ?
* Perhaps this? https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/APIGateway.html#getGatewayResponse-property
* Maybe `getGatewayResponse` . will try.
* `getSdkType` , https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/APIGateway.html#getSdkType-property  , "Calls the GetSdkType API operation. "
* Also [this AWS documentation](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-generate-sdk-javascript.html) that says to use something like `var apigClient = apigClientFactory.newClient();` feels outdated.
* There are EC2, S3, Kinesis, and other examples [here](https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/sdk-code-samples.html) but not APIGateway. I would think API Gateway should be a popular request.

#### config example
* Hmm [this doc](https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/global-config-object.html) has this example..

```
var myCredentials = new AWS.CognitoIdentityCredentials({IdentityPoolId:'IDENTITY_POOL_ID'});
var myConfig = new AWS.Config({
  credentials: myCredentials, region: 'us-east-1'
});

// maybe i can then add...
var apigateway = new AWS.APIGateway (myConfig);
var apigateway = new AWS.APIGateway({apiVersion: '2015-07-09',
                   params: {restApiId: 'xxxx',
                       stageName: 'default'}});


apigateway.getGatewayResponse({responseType: "DEFAULT_4XX",
                               restApiId: 'MY_REST_API_ID'}, function(err, data) {
  if (err) console.log(err, err.stack); // an error occurred
  else     console.log(data);           // successful response
});
```
* tried that ^^^ , and got ..

```
GET https://apigateway.us-east-1.amazonaws.com/restapis/xxxx/gatewayresponses/DEFAULT_4XX 403
AccessDeniedException: ....

AccessDeniedException: User: arn:aws:sts::xxxxx:assumed-role/Cognito_BikeLearnUnauth_Role/CognitoIdentityCredentials is not authorized to perform: apigateway:GET on resource: arn:aws:apigateway:us-east-1::/restapis/xxxx/gatewayresponses/DEFAULT_4XX
```
* Actually a pretty informative error. Wish I knew what the right method was though haha. This is definitely not the one.

```
https://{restapi_id}.execute-api.{region}.amazonaws.com/{stage_name}/
```

##### Oh wow I think I found a really good example
* First, I think the answer to the question of how do you invoke APIs is still to use vanilla HTTP GET/POST. That's why I couldnt find anything for that in the javascript sdk.
* and the javascript sdk , as per this [awesome stack overflow question](https://stackoverflow.com/questions/36929336/how-to-call-aws-api-gateway-endpoint-with-cognito-id-configuration#36941672) , is useful for actually getting the Cognito service to spit back out the tokens I need for filling the HTTP Authorization header...

```javascript
AWS.config.region = 'us-east-1'; // Region
AWS.config.credentials = new AWS.CognitoIdentityCredentials({
  IdentityPoolId: 'us-east-1:XXXXXXXXXXXXXXXXXXXXXXXX' // your identity pool id here
});

AWSCognito.config.region = 'us-east-1';
AWSCognito.config.credentials = new AWS.CognitoIdentityCredentials({
  IdentityPoolId: 'us-east-1:XXXXXXXXXXXXXXXXXXXXXXXX' // your identity pool id here
});

var poolData = {
  UserPoolId: 'us-east-1_XXXXXXXX',
  ClientId: 'XXXXXXXXXXXXXXXXXXXXXXXX'
};
var userPool = new AWSCognito.CognitoIdentityServiceProvider.CognitoUserPool(poolData);


var authenticationData = {
  Username: 'user',
  Password: '12345678',
};
var authenticationDetails = new AWSCognito.CognitoIdentityServiceProvider.AuthenticationDetails(authenticationData);
var userData = {
  Username: 'user',
  Pool: userPool
};
var cognitoUser = new AWSCognito.CognitoIdentityServiceProvider.CognitoUser(userData);
cognitoUser.authenticateUser(authenticationDetails, {
  onSuccess: function (result) {
  console.log('access token + ' + result.getAccessToken().getJwtToken());

  AWS.config.credentials = new AWS.CognitoIdentityCredentials({
    IdentityPoolId: 'us-east-1:XXXXXXXXXXXXXXXXXXXX',
    IdentityId: AWS.config.credentials.identityId,
    Logins: {
      'cognito-idp.us-east-1.amazonaws.com/us-east-1_XXXXXX': result.idToken.jwtToken
    }
  });

  AWS.config.credentials.get(function (err) {
    // now I'm using authenticated credentials
    if(err)
    {
      console.log('error in autheticatig AWS'+err);
    }
    else
    {
      console.log(AWS.config.credentials.identityId);

    }
  });
  },

  onFailure: function (err) {
    alert(err);
  }

});

```
* Also [this aws blog post](https://aws.amazon.com/blogs/mobile/use-amazon-cognito-in-your-website-for-simple-aws-authentication/) looks pretty good too.
* kept original above ^^^ from question.. And tweaking below for my case, which is anonymous as opposed to specific user/pass


##### the cognito post kept getting cancelled.
* I just kept seeing `XHR failed loading: POST` . but per [stackoverflow](https://stackoverflow.com/questions/38374549/xhr-failed-loading-post)  , I needed to prevent my form from reloadingthe page because it was killing the XHR !! right. right.
* So I added `action="#0"` into the `<form>` tag. That fixed that problem

* ANOTHER problem was my cognito call I think was running async, finishing after I was actually calling my API Gateway endpoint.
* So I made the function that calls my endpoint as a parameter to the cognito function ...
* That made the code messy but it started to appear to call in sequence.
```javascript
authParametersFromCognito = function(callback, callback_params) {

  AWS.config.region = 'us-east-1';
  AWS.config.credentials = new AWS.CognitoIdentityCredentials({
        IdentityPoolId: 'MY_IDENTITY_POOL'
      });

  AWS.config.credentials.get(function(err) {
    if (err) {
      console.log("Error: "+err);
      return;
    }
    console.log("Cognito Identity Id: " + AWS.config.credentials.identityId);

    authparameters = {
      'accessKeyId': AWS.config.credentials.accessKeyId,
      'secretAccessKey': AWS.config.credentials.secretAccessKey,
      // save for later...?
      // 'sessionToken': AWS.config.credentials.sessionToken
    }
    //
    console.log('parameters from form: ' + JSON.stringify(callback_params));
    callback(callback_params, authparameters, 'out-div', 'out-div-2');
    });
}

```

#### but now a new problem, now my api gateway call is showing CORS weirdness
* not sure why this is happening now or why not before. I thought I already enabled CORS.
```
Access to XMLHttpRequest at 'https://xxxx.execute-api.us-east-1.amazonaws.com/default/myBikelearnSageLambda?birth_year=&rider_gender=&rider_type=&start_station=&start_time=' from origin 'https://bike-hop-predict.s3.amazonaws.com' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
```
* Did my resource change?
* This is especially weird, because on the API Gateway, I have this in my "Enable CORS" setting:

```
Access-Control-Allow-Origin*: '*'
```
* And the `'*'` means every origin is allowed.

```
'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'
```

##### changing back to original code
* Hmm now I also dont know what happened but now the original code is getting a `401` now. (not a CORS error?)
* But i did switch over to the new authorizer however. so perhaps this is related to new authorization ..
* Ok, and when I switched back to original authorizer, code now works again .


### 2020-09-15

#### try cors  again
* also interesting [stack here](https://stackoverflow.com/questions/48140465/aws-cognito-and-cors-security-concern)
* So trying again now w/ the Cognito approach , and getting back a `401` and a console error again says

```
Access to XMLHttpRequest at https://xxxx.execute-api.us-east-1.amazonaws.com/default/myBikelearnSageLambda?birth_year=&rider_gender=&rider_type=&start_station=&start_time= from origin https://bike-hop-predict.s3.amazonaws.com has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
```

* and the response from the error is also kind of interesting... maybe I can look that up. Not sure where the console log 'CORS' error is coming from. guess thats the browser itself generating that error?

```
{"readyState":0,"status":0,"statusText":"error"}
```
* But the Cognito call which happens first did not fail and when I look at the credentials in `AWS.config.credentials` , they were filled in .
```
{
			'accessKeyId': AWS.config.credentials.accessKeyId,
			'secretAccessKey': AWS.config.credentials.secretAccessKey,
			// save for later...
			// 'sessionToken': AWS.config.credentials.sessionToken
		}
```

### 2020-09-16

#### That error..
* that `{"readyState":0,"status":0,"statusText":"error"}` response... looks same as [here](https://salesforce.stackexchange.com/questions/158448/response-status-is-0-in-jquery-ajax)  
* And one person notes interestingly, _"A Status Code of 0 means "the browser refused to honor the request." "_ . Good to know haha.
* So that makes me think indeed CORS related still.
* hmm... something tells me I got to use the session token `AWS.config.credentials.sessionToken` in the V4 signature as well. I had been reading about this before as an optional component...
* [v4 troubleshooting](https://docs.aws.amazon.com/general/latest/gr/signature-v4-troubleshooting.html) may be useful later.

#### Security Token Service
* Hmm according to this Note ... [here](https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html)

> You can use temporary security credentials provided by the AWS Security Token Service (AWS STS) to sign a request. The process is the same as using long-term credentials, but when you add signing information to the query string you must add an additional query parameter for the security token. The parameter name is X-Amz-Security-Token, and the parameter's value is the URI-encoded session token (the string you received from AWS STS when you obtained temporary security credentials).
> For some services, you must include the X-Amz-Security-Token query parameter in the canonical (signed) query string. For other services, you add the X-Amz-Security-Token parameter at the end, after you calculate the signature. For details, see the API reference documentation for that service.

* It looks like the `AWS.config.credentials.sessionToken` is the STS token which per above, depends on the service as to where it should go in the request as the `X-Amz-Security-Token` header.
* I dont see the Security Token mentioned [here](https://docs.aws.amazon.com/apigateway/api-reference/signing-requests/) hmm.
* Per [this](https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html) ...

> You can use temporary security credentials provided by the AWS Security Token Service (AWS STS) to sign a request. The process is the same as using long-term credentials.

* Maybe using `X-Amz-Security-Token` is optional ?  
* this [blog post](https://jun711.github.io/aws/how-to-sign-api-gateway-requests-with-signature-version-4-using-aws-amplify/) although it uses Amplify , but it shows at least the use of the `X-Amz-Security-Token` header following the `x-amz-date` header in the `execute-api` HTTP request. So maybe that's a path to try next?

#### Next
* So per above perhaps I can try use of `X-Amz-Security-Token` as per this blog post.
* Actually haha I am looking at the `aws-sign-web.js` which I have been using all this time... and the `sessionToken` may be provided actually.

### 2020-09-17

#### ok try that bonus sessionToken
* ... I just added that into the `var signer = new awsSignWeb.AwsSigner(config);`
* hmm per [this example](https://jun711.github.io/aws/how-to-sign-api-gateway-requests-with-signature-version-4-using-aws-amplify/) , the `x-amz-security-token` should be part of the headers and part of the "SignedHeaders" section of the "Authorization" header.
* But when I look at `aws-sign-web.js` it includes in the `AWsSigner.prototype.sign` func, but I don't see it in the `headers` which are actually being prepared to be sent.
* So yea perhaps `aws-sign-web.js` doesnt work for using sessionToken out of the box.

#### Also looked at the Cloudwatch API Gateway logs
* Seeing flat out the cognito Authorizer I have set up `hht41e` is being called out in the log and it is simply saying it is unauthorized.

```
(d07215c7-d495-4ecf-9274-e78b4b17e9d5) Starting authorizer: hht41e for request: d07215c7-d495-4ecf-9274-e78b4b17e9d5
(d07215c7-d495-4ecf-9274-e78b4b17e9d5) Unauthorized request: d07215c7-d495-4ecf-9274-e78b4b17e9d5
```

* Also kind of nice the API gateway cloudwatch log also loging the `OPTIONS` request ... and I can see the response headers..
```
(211ac0bb-7227-4a49-836c-f33cd9f3eeea) Method response headers: {Access-Control-Allow-Headers=Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token, Access-Control-Allow-Methods=GET,OPTIONS,POST, Access-Control-Allow-Origin=*, Content-Type=application/json}
```
* So yea most likely the response that is being generated is not allowed in the CORS somehow , so a `401` is masquerading as a `CORS` error. I feel like I've seen this before.

#### Summary
* For sure I now know that Cognito Auth issues are masquerading as CORS issues.

#### Next
* the CORS is for sure obscuring the Authorization error I'm seeing. I think I need to try to use `curl` to troubleshoot the Authorization/ signature itself, possibly just doing the Signature from scratch, maybe I can use python to create the request material since that is a bit easier.
* Then once the using `curl` I get the Cognito Auth straightened out, I can try in a browser again.


### 2020-09-18

#### make a raw python request
* I will use my existing javascript to generate the signature
```python
import requests

API_ID = os.getenv('API_ID')


curl \
Request URL:

x-amz-date: 20200917T143905Z
authorization: AWS4-HMAC-SHA256 Credential=xxxxxxO3UIME/20200917/us-east-1/execute-api/aws4_request, SignedHeaders=accept;host;x-amz-date, Signature=a7626a275f49ac57a5671bfbc81a3ba92a1b9bf772b682a2cece125ce4438625
accept: application/json


headers = {
    'Accept': "application/json",
    'Authorization': "AWS4-HMAC-SHA256 Credential=xxxxxxxGQOIOR/20200918/us-east-1/execute-api/aws4_request, SignedHeaders=accept;host;x-amz-date, Signature=c1f54f3bab31cd958e80293995db1551a4053a6a65abcce1bfd3b204f59a86e6",
    'x-amz-date': "20200918T143405Z"
    }

API_ID = 'xxx'
r = requests.get(url=f'https://{API_ID}.execute-api.us-east-1.amazonaws.com/default/myBikelearnSageLambda?birth_year=&rider_gender=&rider_type=&start_station=&start_time=',
    headers=headers)

```
* Dang. So I dumped the javascript output and called with python requests, but the response was not informative.. just

```python

In [35]: r                                                                                        
Out[35]: <Response [401]>

In [36]: r.json()                                                                                 
Out[36]: {'message': 'Unauthorized'}
```

#### SDK generation
* I was able to download an sdk from api gateway.
* no Cognito there though .

#### Summary
* hmm so it's intriguing that w/ the raw python request, indeed i see the `401` and the CORS issue indeed hides the authentication issue.
* The API Gateway + Incognito + javascript is poorly documented.
* The error message was simply 'Unauthorized' whereas I know in earlier attempts to authenticate against API Gateway using python, I've seen messages like `{'message': 'The request signature we calculated does not match the signature you provided. Check your AWS Secret Access Key and signing method. Consult the service documentation for details.\n\nThe Canonical String for this request should have been...'}`
where the error literally said the `Canonical String` etc..

### 2020-09-19

#### let me see if i can increase the level of error messaging from API Gateway hmm
* Maybe then with more feedback I can get better intel whats going on.
* hmm according to [docs](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-gatewayResponse-definition.html) , I can control the _Response template_ of errors, and I can add additional information around three areas,
  * `$context`
  * `$stageVariables`
  * ` method.request.param-position.param-name`
* Checking out the [context](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#context-variable-reference) section ... hmm

#### ok i added a new piece of context. going to retest
* I changed the response template to
```
{"message":$context.error.messageString, "validation": $context.error.validationErrorString}
```
```python
def js_to_python(url, raw):
    m = re.search(
            (r'\sAccept: "(?P<accept>[^"]*)"\s'
            r'Authorization: "(?P<auth>[^"]*)"\sx-amz-date: "(?P<date>[^"]*)"'), raw); m.groupdict()
    headers = {}

    headers = {
    'Accept': m['accept'],
    'Authorization': m['auth'],
    'x-amz-date': m['date']
    }

    r = requests.get(url=url,
    headers=headers)
    return r
    # return r.status_code, r.json()
url = f'https://{API_ID}.execute-api.us-east-1.amazonaws.com/default/myBikelearnSageLambda?birth_year=&rider_gender=&rider_type=&start_station=&start_time='

raw = '''
....
'''
r = js_to_python(url, raw)

```
* Damn now `r.json()` failed because response isn't even json...
```
# JSONDecodeError: Expecting value: line 1 column 42 (char 41)
In [75]: r.text                                                                                   
Out[75]: '{"message":"Unauthorized", "validation": }'
```
* Somehow that context was null.

##### I also tried ..
```
{"message":$context.error.messageString, "validation": "$context.error.validationErrorString", "response_type" : "$context.error.responseType", "cognitoAuthenticationType": "$context.identity.cognitoAuthenticationType"}
```
* But got back..
```
Out[78]: '{"message":"Unauthorized", "validation": "", "response_type" : "UNAUTHORIZED", "cognitoAuthenticationType": ""}'
```
* So is that saying that the gateway doesnt see any evidence the request was signed by a Cognito identity. I wonder if thats the case for both Authenticated and Unauthenticated.

* Hmm one positive note, I was able to select the "Enable Access Logging" option on my APIGateway stage, and in CloudWatch I created a new log group. I added that log group's arn to this "Enable Access Logging" area and now requests are getting logged.
* So far the default information is not interesting. But going to look at the [docs](https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-logging.html) , hopefully some interesting log variables can be added !

### 2020-09-20

#### other logs
* Hmm wondering Authorizer logs? Not seeing those in cloudwatch though
* Maybe there's a Cognito log? hmm cant find

#### trying out python approach for now ...

```python
import aws_v4

# url = f'https://{API_ID}.execute-api.us-east-1.amazonaws.com/default/myBikelearnSageLambda?birth_year=&rider_gender=&rider_type=&start_station=&start_time='
API_ID = 'xxx'
url = f'https://{API_ID}.execute-api.us-east-1.amazonaws.com/default/myBikelearnSageLambda'
request_dict = {
    'birth_year': '', 'rider_gender': '',
    'rider_type': '', 'start_station': '', 'start_time': ''}

raw = '''
....
'''
headers = aws_v4.js_to_python(url, raw)

# from an earlier chrome session
access_key, secret_key = "xxxxxxxX45", "xxxxxxxxx"
region = 'us-east-1'
auth = aws_v4.GET_create_api_gateway_auth(url, request_dict, region, access_key, secret_key)
auth
r = requests.get(url, json=request_dict, headers=auth)
r

```
* Interesting, now I got a response, different from `Unauthorized` finally...
```python
In [35]: r                                                                                                    
Out[35]: <Response [403]>

In [36]: r.text                                                                                               
Out[36]: '{"message":"The security token included in the request is invalid."}'
```
* But I had used access key from yesterday so maybe they were expired by now , maybe a fulle day later.
* Going to try again with a fresh access key...
* ...
```python
url = f'https://{API_ID}.execute-api.us-east-1.amazonaws.com/default/myBikelearnSageLambda'
request_dict = {
    'birth_year': '', 'rider_gender': '',
    'rider_type': '', 'start_station': '', 'start_time': ''}
#
access_key, secret_key = "xxxxxxxT3SS", "xxxxxxxCxH/gP"
region = 'us-east-1'
auth = aws_v4.GET_create_api_gateway_auth(url, request_dict, region, access_key, secret_key)
auth
full_url = f'{url}?{qs}'
r = requests.get(full_url, json=request_dict, headers=auth)
r
```
* Ok, refreshed the access key and yet against getting that `401`
```python
Out[41]: <Response [401]>

In [42]: r.json()                                                                                             
Out[42]:
{'message': 'Unauthorized',
 'validation': '',
 'response_type': 'UNAUTHORIZED',
 'cognitoAuthenticationType': '',
 'path': '/default/myBikelearnSageLambda',
 'user-agent': 'python-requests/2.22.0',
 'caller': ''}
```

##### wow i noticed I did not have the execute api policy on the cognito role
* Ok but I added the `bikeLearnAPIexecute` policy, but still getting the `401` `Unauthorized`
* Going to manufactor another access key and retry ...
* Hmm still no good

##### I switched to the AWS IAM Authorization type briefly
* So that I can test drive that the python signing is good.
* Oddly enough the response in the request was indeed getting backa bout the detail of the Canonical Signature , ( complaining about the recommendation in [this example](https://docs.aws.amazon.com/code-samples/latest/catalog/python-signv4-v4-signing-get-querystring.py.html) to put the X amazon heaaders into the QueryString )
* ...

```python
Out[61]:
(403,
 {'message': "The request signature we calculated does not match the signature you provided. Check your AWS Secret Access Key and signing method. Consult the service documentation for details.\n\nThe Canonical String for this request should have been\n'GET\n/default/myBikelearnSageLambda\nbirth_year=&rider_gender=&rider_type=&start_station=&start_time=\ncontent-type:application/x-amz-json-1.0\nhost:rmuxqpksz2.execute-api.us-east-1.amazonaws.com\nx-amz-date:20200920T211730Z\n\ncontent-type;host;x-amz-date\ne3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n\nThe String-to-Sign should have been\n'AWS4-HMAC-SHA256\n20200920T211730Z\n20200920/us-east-1/execute-api/aws4_request\n2727b324b1a2810f723f1865bb33575dd1944f33b0b9cb7fcb86f975d4aa26fd'\n"})

In [62]: print(r.json()['message'])                                                                            
The request signature we calculated does not match the signature you provided. Check your AWS Secret Access Key and signing method. Consult the service documentation for details.

The Canonical String for this request should have been
'GET
/default/myBikelearnSageLambda
birth_year=&rider_gender=&rider_type=&start_station=&start_time=
content-type:application/x-amz-json-1.0
host:rmuxqpksz2.execute-api.us-east-1.amazonaws.com
x-amz-date:20200920T211730Z

content-type;host;x-amz-date
e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'

The String-to-Sign should have been
'AWS4-HMAC-SHA256
20200920T211730Z
20200920/us-east-1/execute-api/aws4_request
2727b324b1a2810f723f1865bb33575dd1944f33b0b9cb7fcb86f975d4aa26fd'

```
* I fixed this ^^ and now I'm getting a brand new error, a `415` ...
```python
Out[69]: (415, {'message': 'Unsupported Media Type'})
```
* According to [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/415) the `Content-type` I'm passing, `content_type = 'application/x-amz-json-1.0'` is not good. But it is a recommendation from [here](https://docs.aws.amazon.com/code-samples/latest/catalog/python-signv4-v4-signing-get-post.py.html)  
* Hmm but per [the Querystringt doc](https://docs.aws.amazon.com/code-samples/latest/catalog/python-signv4-v4-signing-get-querystring.py.html) there is actually no mention of `Content-type`
* Hmm, maybe that is only a `POST` thing then?

##### took out that content type now its good
* Cool, so now have working GET as well. just w/o the query string

#### Summary
* I malformed the cognito access keys and the message changed from `Unauthorized` to `"The security token included in the request is invalid."`
* OOps I ended up the `UnauthCognitoRole` I had actually didnt have the required permission to 'execute' the API gateway. I added that. although I still was getting the `401 Unauthorized` so may be some other problems...

#### Next
* Can try the vetted GET code against a token I got from cognito
* maybe maybe longshot is to use the STS token too.
* But if it doesnt work now then a Role misconfiguration or authorizer misconfiguration hmm..

### 2020-09-21

#### try yesterdays `aws_v4.GET_create_api_gateway_auth` func w yesterdays cognito access key

```python

# access key from the cognito... try one from yesterday first...
access_key, secret_key = "xxxxxxx3SS", "xxxxxxxxxmYZ1CxH/gP"
# access_key, secret_key =
region = 'us-east-1'
print(url)
auth = aws_v4.GET_create_api_gateway_auth(url, request_dict, region, access_key, secret_key)
print('full_url', full_url)
print('auth', auth)
r = requests.get(full_url, headers=auth)
r.status_code, r.json()

```
* ok getting
```
Out[79]: (403, {'message': 'The security token included in the request is invalid.'})
```
* Perhaps the token does indeed expire..

#### try `aws_v4.GET_create_api_gateway_auth` with a fresh cognito access key ..

```python
access_key, secret_key = 'xxxxxx3HB', "xxxxxxxxx"
region = 'us-east-1'
print(url)
auth = aws_v4.GET_create_api_gateway_auth(url, request_dict, region, access_key, secret_key)
print('full_url', full_url)
print('auth', auth)
r = requests.get(full_url, headers=auth)
r.status_code, r.json()

```
* hmm same thing
```
Out[80]: (403, {'message': 'The security token included in the request is invalid.'})
```
* wait a second... security token...!! not access key
* Hmm, but [this stackoverflow q](https://stackoverflow.com/questions/56835781/unrecognizedclientexception-the-security-token-included-in-the-request-is-inval)  has an answer that suggests _" Either the accessKeyId or secretAccessKey (or both) are wrong."_
* ( This uses [this ](https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html) )
```
aws sts get-caller-identity --cli-input-json
aws sts get-caller-identity --generate-cli-skeleton

aws sts get-caller-identity --cli-input-json '{"AccessKeyId": "xxxxx3HB", "SecretAccessKey": "xxxxxxx"}'

Parameter validation failed:
Unknown parameter in input: "accessKey", must be one of:
Unknown parameter in input: "secretKey", must be one of:
```
* But when I inquire about this cognito generated key like this. .. my account pops back...
```
(pandars3) $ aws --profile adminuser sts get-access-key-info --access-key-id xxxxxxx3HB
{
    "Account": "xxxxxxx"
}
```

* Ok I put the information into my `.aws/credentials` and getting this

```
(pandars3) $ aws --profile tempcognito sts get-caller-identity

An error occurred (InvalidClientTokenId) when calling the GetCallerIdentity operation: The security token included in the request is invalid.
(pandars3) $
```
* SO honestly, this isn't a permission thing... but I think it's something like this token is messed up somehow.

### 2020-09-28

#### hmm
* So to digest previous efforts, the cognito generated keys are real identities, but either they have wrong permissions or I need to use them only with a token? But Per stack overflow
* Per that [that stackoverflow response](https://stackoverflow.com/questions/56835781/unrecognizedclientexception-the-security-token-included-in-the-request-is-inval) about using [GetCallerIdentity ](https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html) , I checked and when I use aws cli `sts get-caller-identity` indeed asking about my cognito credential throws a fuss..

#### Next
* Got to keep digging into my Cognito configuration. Tempted to simply try the "authenticated" pool. Just create an identity, see if that works. if so then perhaps thats a good enough proof of concept..


### 2020-09-29

#### back..
* Reading [this stack overflow question](https://stackoverflow.com/questions/36929336/how-to-call-aws-api-gateway-endpoint-with-cognito-id-configuration#36941672) again, per my [earlier notes](oh-wow-i-think-i-found-a-really-good-example)
* I want to try again but authenticated this time..
* reading a comment in there _"If you are using temporary credentials you must include the session token"_ , now I want to try that..

#### session in place of secret...
* I simply put the session_token in place of the secret. (Still got same `Unauthorized` though. )
```python
access_key, secret_key = 'xxxxxxx', "xxxxxxxxx"
session_token = 'IQoJb3JpZ2luX2VjEB4aCXVzLWVhc3QtMSJGMEQxxxxxx........CvHHVcnl8VNFmkWcBuATKqAcgPR7VLOgPu2eCUoswjnj3qQN0'
region = 'us-east-1'
print(url)
auth = aws_v4.GET_create_api_gateway_auth(url, request_dict, region, access_key, session_token)
print('full_url', full_url)
print('auth', auth)
r = requests.get(full_url, headers=auth)
r.status_code, r.json()


```

* Ah ok no that ^^ is wrong according to [doc](https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html)
* I know i'm probably reading this the second time already probably ...

> You can use temporary security credentials provided by the AWS Security Token Service (AWS STS) to sign a request. The process is the same as using long-term credentials, but requires an additional HTTP header or query string parameter for the security token. The name of the header or query string parameter is X-Amz-Security-Token, and the value is the session token (the string you received from AWS STS when you obtained temporary security credentials).

> When you add the X-Amz-Security-Token parameter to the query string, some services require that you include this parameter in the canonical (signed) request. For other services, you add this parameter at the end, after you calculate the signature. For details, see the API reference documentation for that service.

* Let me try to add this extra token somehow...

```python

access_key, secret_key = 'xxxxx', "xxxxxx"
# session_token = 'IQoJb3JpZ2luX2VjEB4aCXVzLWVhc3QtMSJGMEQCIFJrLe+xIf........CvHHVcnl8VNFmkWcBuATKqAcgPR7VLOgPu2eCUoswjnj3qQN0'
region = 'us-east-1'
print(url)
auth = aws_v4.GET_create_api_gateway_auth(url, request_dict, region, access_key, secret_key,
                                          session_token=session_token)
print('full_url', full_url)
print('auth', auth)
r = requests.get(full_url, headers=auth)
r.status_code, r.json()


```
* Dang still nothing

#### Summary
* Well.. i tried one of the recommendations for placing that session token ... into the canonical header
* Per that doc I referenced ^^ I can also try stuffing into query string or it says for some services it is meant to be included after calculating the signature. Cognito is a subset of STS per research so maybe searching explicitly for STS plus HTTP requests will help know how to do this ...



### 2020-09-30

#### that "Authenticated approach"
* I created a "User Pool". Wow thats intense. Now I have a "Pool Id"
* But I don't see a client id as would be needed in [this example](https://stackoverflow.com/questions/36929336/how-to-call-aws-api-gateway-endpoint-with-cognito-id-configuration#36941672) hmm so this requires more effort indeed


#### also this interesting ipython AWS auth documentation
* [here](https://github.com/MateusAmin/requests-aws-iam-auth/blob/master/requests_aws_iam_auth/api_gateway.py)
* these imports are available in botocore cool..
```python

from botocore.awsrequest import AWSRequest  # type: ignore
from botocore.session import Session  # type: ignore
from botocore.auth import SigV4Auth  # type: ignore
from requests.auth import AuthBase
from requests import PreparedRequest

```
* Hmmm... this example is interesting but it doesnt seem to explain how `x-amz-security-token` is handled. Says not to sign though .


#### Next
* That "Auth" approach seems intense, will put that one off for now,
* But since last time I had signed the `x-amz-security-token` header that I passed, next I would like to try the not signed variation, per the alternative mentioned in the [doc](https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html) and also in this [github repo example](https://github.com/MateusAmin/requests-aws-iam-auth/)


### 2020-10-02

#### Going to try to add the `x-amz-security-token` unsigned

```python
access_key, secret_key = 'xxxxx', "xxxx"
session_token = "IQoJb3JpZ2luX2xxxxxxJGMaf0Ou2obrtI1jVcNP+kSz3AU+Y26heeXY2qO+jQze00rmUH3jpo"
region = 'us-east-1'
print(url)
# so keeping this session_token=None
auth = aws_v4.GET_create_api_gateway_auth(url, request_dict, region, access_key, secret_key,
                                          session_token=None)
# but add it anyway...
auth['X-Amz-Security-Token'] = session_token
print('full_url', full_url)
print('auth', auth)
r = requests.get(full_url, headers=auth)
r.status_code, r.json()
```
* Damn still didnt work

```
(401,
 {'message': 'Unauthorized',
  'validation': '',
  'response_type': 'UNAUTHORIZED',
  'cognitoAuthenticationType': '',
  'path': '/default/myBikelearnSageLambda',
  'user-agent': 'python-requests/2.22.0',
  'caller': ''})
```

#### not sure what else is there left to try ...
* I am looking at my Authorizer, `CognitoUnAuthAuth` and I'm seeing the User Pool, `a20ce22xxxx-xxx-57d007e7` ,
* But these names are kind of confusing. Does that mean this is authenticated ? Am I setting that up to fail for UnAuth?

#### IAM?
* Hmm I changed over to IAM Authorization since I suspect "Cognito Authorizer" is strictly for "Authenticated" users.
* Now I am actually getting a different error, saying my signature is wrong.. this is promising...
* My `r.status_code` is actually a `403` not a `401`  also..

```python
In [99]: print(r.json()['message'])                                                                            
The request signature we calculated does not match the signature you provided. Check your AWS Secret Access Key and signing method. Consult the service documentation for details.

The Canonical String for this request should have been
'GET
/default/myBikelearnSageLambda
birth_year=&rider_gender=&rider_type=&start_station=&start_time=
host:rmuxqpksz2.execute-api.us-east-1.amazonaws.com
x-amz-date:20201002T143455Z
x-amz-security-token:IQoJb3JpZ2luX2VjEGcaCXVzLWVhc3QtMSJGMEQCIFqo9XllsBZX9ks5oUtzGRo5uDphLoatu9iCDlcIwZ4wAiAdfm07H62eip/yoY/04VFcpxcQqaX5n6gn3cpZeG1qoyqXBgiP//////////8BEAAaDDMyOTM0NTE3MzE2NiIMuzJ6uhwVQd3IZzKdKusF/fPivvLYatXz1mlFCSRWztrC2+4IiZX7mmA2NpWGYYfbzBn+myAL+tx05Q2oxr7AjOU38QnIAhNfG090m/lbo7qFrIbW9E9/NpQQLQ1689edbpV0KgZrB148lbEo44eWRKjvmTus+UPzsRj77zRJoWI/ZDOG20HPJew6YOnqknKkM/z4umsK90qMk/zicraRjzlLai9CKbwSam2j/i0p95deOw/vLLMZQHV5Gu3OztdAMX9vjpz2pTQPccW5xpCqjkV8uaLUCVxSTiklQ0Jl+3ZvA0wC/S3fZfQ6QJFiwsSkueD1EZxDf/4q2i936L/CurdMPxHuj8q2Yh/SLjMLWCMtkL/B2W6zXp80PzAnyPCpcF8vrL1JOrPjaExS/8SlK4JSDikQ81UeNiQ85both2+ErA4gwJQyWg6ukWyc6SqWChlkJseMUSKJaH9v0ZcvpeR08u65MnBuQ7sgf8P1igq7SUzb5NRhBYitqJan1pLDJlDwhz2UJ0dKVh818naWXKmrUnkntyXzxfRx0RTXW95p/GSFsLR/rsQul7nWdHY2TedRCu9rN7REVznZxFySrpjQczUIShoyXqzUxCYnezZETKNKpfGsFKDm8T1pIdLRn0UM4N9Tf+MSsTJgW3+RRo4Aus+P9h/BytPdfNXCD9QwHPmez9qUlo0YxbX57cR+ZjA/jtNE1oocd1To82Ug5RgiPrYJe1gYKli547Iw3goQVD/ay0EUnBa95OyN+7GeNo687/U/0H9l6a3UsZBzl9pgGuQ/2DbVDtsZ3nXrA+9G2GXwMogqxoO8nQ/CPDcE7CPz0orIvd2dViZ7wnf+ukjWcqGSO9pLIq1n0QUG4bI5c8dXfReOmIfkttJ++m6QacgTvAUYv86kY9RDmZmYVaQHAs/lklSKoNwhLAwVLBo4i4XPGA8QiShNlYrzWX0Pltefz2LjYpAHEDRli7BGSf7jx3NJJOyGqRoJdpN7JnttaI+ERspK9Sq5MILu3PsFOogCdfhTu/AwY2af4nlsZq5YEo5fbMoWPICqcn42Ko22K2mFBVpWMqRfu/AN2qNt2pwl/fJXK2Psa9vddZZn78/8C6OBS+ciKsrn+31TZiukfx+K23QnY0CRrUPEoZEbmECMhCs+0mujBFTPmP7RwTaMjrSVPznHD0awwGyAo2r9rRMcXdb9yWcCMU61ELfT1Qyl4+jA0GnTNV4Yv/uvotE9Hu4J1KeupgFmgZA6Mi3o7GmRu8CfOyHgdrZvQP0jxRpWLlVkJZ0j/RulmwkQ9I0+0YpA4fbLkBLBEMwzDBxplQJGMaf0Ou2obrtI1jVcNP+kSz3AU+Y26heeXY2qO+jQze00rmUH3jpo

host;x-amz-date;x-amz-security-token
e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'

The String-to-Sign should have been
'AWS4-HMAC-SHA256
20201002T143455Z
20201002/us-east-1/execute-api/aws4_request
91e59f1e851dac8c3259bbfc1e12d1a35a800c8301e730155c7f4b12fe8ce31f'
```

* retry like above...
* Hmm for one thing... I had a bug where I was missing the `:` colon after `x-amz-security-token` in the Canonical String !!
* I retried and now getting...

```python
In [103]: print(r.json()['message'])                                                                           
The request signature we calculated does not match the signature you provided. Check your AWS Secret Access Key and signing method. Consult the service documentation for details.

The Canonical String for this request should have been
'GET
/default/myBikelearnSageLambda
birth_year=&rider_gender=&rider_type=&start_station=&start_time=
host:rmuxqpksz2.execute-api.us-east-1.amazonaws.com
x-amz-date:20201002T145056Z
x-amz-security-token:IQoJb3JpZ2luX2VjEGcaCXVzLWVhc3QtMSJGMEQCIFqo9XllsBZX9ks5oUtzGRo5uDphLoatu9iCDlcIwZ4wAiAdfm07H62eip/yoY/04VFcpxcQqaX5n6gn3cpZeG1qoyqXBgiP//////////8BEAAaDDMyOTM0NTE3MzE2NiIMuzJ6uhwVQd3IZzKdKusF/fPivvLYatXz1mlFCSRWztrC2+4IiZX7mmA2NpWGYYfbzBn+myAL+tx05Q2oxr7AjOU38QnIAhNfG090m/lbo7qFrIbW9E9/NpQQLQ1689edbpV0KgZrB148lbEo44eWRKjvmTus+UPzsRj77zRJoWI/ZDOG20HPJew6YOnqknKkM/z4umsK90qMk/zicraRjzlLai9CKbwSam2j/i0p95deOw/vLLMZQHV5Gu3OztdAMX9vjpz2pTQPccW5xpCqjkV8uaLUCVxSTiklQ0Jl+3ZvA0wC/S3fZfQ6QJFiwsSkueD1EZxDf/4q2i936L/CurdMPxHuj8q2Yh/SLjMLWCMtkL/B2W6zXp80PzAnyPCpcF8vrL1JOrPjaExS/8SlK4JSDikQ81UeNiQ85both2+ErA4gwJQyWg6ukWyc6SqWChlkJseMUSKJaH9v0ZcvpeR08u65MnBuQ7sgf8P1igq7SUzb5NRhBYitqJan1pLDJlDwhz2UJ0dKVh818naWXKmrUnkntyXzxfRx0RTXW95p/GSFsLR/rsQul7nWdHY2TedRCu9rN7REVznZxFySrpjQczUIShoyXqzUxCYnezZETKNKpfGsFKDm8T1pIdLRn0UM4N9Tf+MSsTJgW3+RRo4Aus+P9h/BytPdfNXCD9QwHPmez9qUlo0YxbX57cR+ZjA/jtNE1oocd1To82Ug5RgiPrYJe1gYKli547Iw3goQVD/ay0EUnBa95OyN+7GeNo687/U/0H9l6a3UsZBzl9pgGuQ/2DbVDtsZ3nXrA+9G2GXwMogqxoO8nQ/CPDcE7CPz0orIvd2dViZ7wnf+ukjWcqGSO9pLIq1n0QUG4bI5c8dXfReOmIfkttJ++m6QacgTvAUYv86kY9RDmZmYVaQHAs/lklSKoNwhLAwVLBo4i4XPGA8QiShNlYrzWX0Pltefz2LjYpAHEDRli7BGSf7jx3NJJOyGqRoJdpN7JnttaI+ERspK9Sq5MILu3PsFOogCdfhTu/AwY2af4nlsZq5YEo5fbMoWPICqcn42Ko22K2mFBVpWMqRfu/AN2qNt2pwl/fJXK2Psa9vddZZn78/8C6OBS+ciKsrn+31TZiukfx+K23QnY0CRrUPEoZEbmECMhCs+0mujBFTPmP7RwTaMjrSVPznHD0awwGyAo2r9rRMcXdb9yWcCMU61ELfT1Qyl4+jA0GnTNV4Yv/uvotE9Hu4J1KeupgFmgZA6Mi3o7GmRu8CfOyHgdrZvQP0jxRpWLlVkJZ0j/RulmwkQ9I0+0YpA4fbLkBLBEMwzDBxplQJGMaf0Ou2obrtI1jVcNP+kSz3AU+Y26heeXY2qO+jQze00rmUH3jpo

host;x-amz-date;x-amz-security-token
e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'

The String-to-Sign should have been
'AWS4-HMAC-SHA256
20201002T145056Z
20201002/us-east-1/execute-api/aws4_request
b42ddcd7a1409fed7647a1d684d79d403e47fe2910957f2fb153a0e52c883e8b'
```
* Hmm i can't spot the difference. This all seems actually correct.
* I tried to capture and compare both but getting `True` indeed
```python
In [110]: mycanonical_string == shouldhavebeen_canonical_string                                                
Out[110]: True

In [111]: my_string_to_sign = '''AWS4-HMAC-SHA256
     ...: 20201002T145056Z
     ...: 20201002/us-east-1/execute-api/aws4_request
     ...: b42ddcd7a1409fed7647a1d684d79d403e47fe2910957f2fb153a0e52c883e8b'''                                  

In [112]: should_have_been_string_to_sign = '''AWS4-HMAC-SHA256
     ...: 20201002T145056Z
     ...: 20201002/us-east-1/execute-api/aws4_request
     ...: b42ddcd7a1409fed7647a1d684d79d403e47fe2910957f2fb153a0e52c883e8b'''                                  

In [113]: my_string_to_sign == should_have_been_string_to_sign                                                 
Out[113]: True
```

* maybe expired?

```python

access_key, secret_key = 'xxx', "xxxx"
session_token = "IQoJbxxxxxxxx0if4ipI1eIMgy67npeSUSLMCoHR46YIWG/+yBgCuVOB3vaK7KGysxSQ4cFoABBs8K9qcopDp"
region = 'us-east-1'
print(url)
# so keeping this session_token=None
auth, my_canonical_string, my_string_to_sign = aws_v4.GET_create_api_gateway_auth(url, request_dict, region, access_key, secret_key,
                                          session_token=None)
# but add it anyway...
# auth['X-Amz-Security-Token'] = session_token
print('full_url', full_url)
print('auth', auth)
r = requests.get(full_url, headers=auth)
r.status_code, r.json()

```

* oh my god that finally worked!! wow. so yea perhaps indeed it expires after a little bit of time i might indeed get a message that the signature is bad? Or maybe thats related to time getting mangled in there.


### 2020-10-04
#### Also on python side, tried without the session token
* Since I know now the "Cognito Auth" I had on the API Gateway side was wrong for UnAuth, I tried the python v4 request w/o the session token,
* But getting `Out[122]: (403, {'message': 'The security token included in the request is invalid.'})` so pretty sure now thats required for the temporary STS based authentication.

#### ok did a quick update in fetch_data.js
* quick update and wow now the UnAuth Auth works ! omg yes.

#### ran a quick lambda test
* This is what lambda is seeing in debug in lambda cloudwatch logs..
```
DEBUG,  {'params': {'path': {}, 'querystring': {'birth_year': '', 'rider_gender': '', 'rider_type': '', 'start_station': '', 'start_time': ''}, 'header': {'accept': 'application/json', 'accept-encoding': 'gzip, deflate, br', 'accept-language': 'en-US,en;q=0.9', 'dnt': '1', 'Host': 'xxxxx.execute-api.us-east-1.amazonaws.com', 'origin': 'https://bike-hop-predict.s3.amazonaws.com', 'referer': 'https://bike-hop-predict.s3.amazonaws.com/index.html?', 'sec-fetch-dest': 'empty', 'sec-fetch-mode': 'cors', 'sec-fetch-site': 'cross-site', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36',
```
* And since I know the origin I can actually adjust my CORS accordingly !

#### Next
* Now I just need to deploy lambda that reads the `querystring` input and I'll be set.
